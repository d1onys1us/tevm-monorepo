{"version":3,"sources":["../src/Precompile.ts","../src/definePrecompile.ts","../src/defineCall.ts"],"names":["topics","data"],"mappings":";AACA,SAAS,eAAe;AACxB,OAA4B;AAC5B,SAAmB,aAAa;AAuBzB,IAAe,aAAf,MAML;AAAA,EAKkB,eAAe,MACjC,QAAQ,WAAW,KAAK,SAAS,OAAO;AAAA,EACzB,aAAa,OAAO;AAAA,IACnC,SAAS,KAAK,aAAa;AAAA,IAC3B,UAAU,CAAC,WAAmD;AAC7D,aAAO,KAAK,KAAK,EAAE,MAAM,MAAM,OAAO,IAAI,GAAG,UAAU,OAAO,SAAS,CAAC;AAAA,IACzE;AAAA,EACD;AAKD;;;AC9CO,IAAM,mBAAmB,CAG9B;AAAA,EACD;AAAA,EACA;AACD,MAWK;AACJ,QAAM,cAAc;AAAA,EACpB,MAAM,iCAAiC,WAAqC;AAAA,IAC3E,WAAW;AAAA,IACX,OAAO;AAAA,EACR;AACA,SAAO,IAAI,yBAAyB;AACrC;;;AC1BA,SAAS,iBAAiB,gBAAiC;AAQ3D;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACM;AAYA,IAAM,aAAa,CACzB,KACA,aAMI;AACJ,SAAO,OAAO;AAAA,IACb;AAAA,IACA;AAAA,EACD,MAAsE;AACrE,UAAM,IAAI,mBAAmB;AAAA,MAC5B;AAAA,MACA;AAAA,IACD,CAAC;AACD,UAAM,UAAU,SAAS,EAAE,YAAY;AACvC,QAAI;AACH,YAAM;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACD,IAAI,MAAM,QAAQ;AAAA,QACjB;AAAA,QACA,MAAM,EAAE;AAAA,MACT,CAAC;AACD,aAAO;AAAA,QACN;AAAA,QACA,GAAI,QAAQ,EAAE,eAAe,MAAM,IAAI,CAAC;AAAA,QACxC,GAAI,eAAe,EAAE,aAAa,IAAI,CAAC;AAAA,QACvC,GAAI,cAAc,EAAE,YAAY,IAAI,CAAC;AAAA,QACrC,GAAI,OACD;AAAA,UACA,MAAM,KAAK,IAAI,CAAC,QAAQ;AACvB,kBAAM,SAAS,kBAAkB;AAAA,cAChC;AAAA,cACA,WAAW,IAAI;AAAA,cACf,MAAM,IAAI;AAAA,YACX,CAAQ,EAAE,IAAI,CAACA,YAAW,WAAWA,OAAM,CAAC;AAC5C,kBAAM,YAAY,IAAI;AAAA,cACrB,CAAC,SAAS,KAAK,SAAS,WAAW,KAAK,SAAS,IAAI;AAAA,YACtD;AACA,gBAAI,CAAC;AACJ,oBAAM,IAAI,MAAM,SAAS,IAAI,IAAI,mBAAmB;AACrD,kBAAMC,QAAO,oBAAoB,UAAU,QAAQ,IAAI,MAAM;AAC7D,mBAAO,CAAC,WAAW,IAAI,OAAO,GAAG,QAAQ,WAAWA,KAAI,CAAC;AAAA,UAC1D,CAAC;AAAA,QACD,IACA,CAAC;AAAA,QACJ,aAAa;AAAA,UACZ,qBAAqB;AAAA,YACpB;AAAA,YACA,cAAc,EAAE;AAAA,YAChB,QAAQ;AAAA,UACT,CAAQ;AAAA,QACT;AAAA,MACD;AAAA,IACD,SAAS,GAAG;AACX,aAAO;AAAA,QACN,kBAAkB,OAAO,CAAC;AAAA,QAC1B,aAAa,OAAO,MAAM,CAAC;AAAA,QAC3B,gBAAgB;AAAA,UACf,GAAG,IAAI,SAAS,gBAAgB,MAAM;AAAA,UACtC,GAAG;AAAA,YACF,SACC,OAAO,MAAM,WACV,IACA,aAAa,QACb,EAAE,UACF;AAAA,UACL;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD","sourcesContent":["import type { ExecResult } from '@ethereumjs/evm'\nimport { Address } from '@ethereumjs/util'\nimport { type Script } from '@tevm/contract'\nimport { type Hex, toHex } from 'viem'\n\n/**\n * A precompile is a contract that is deployed at a specific address but runs JavaScript code instead of EVM code.\n * It is constructed via a Tevm {@link Script} and a JavaScript function that implements the precompile.\n * @example\n * import { defineCall, definePrecompile } from '@tevm/precompiles'\n * import { Fs } from './Fs.s.sol'\n *\n * export const fsPrecompile = definePrecompile({\n * \tcontract:\n * \t\tFs.withAddress(\n * \t\t\t`0x${'f2'.repeat(20)}`,\n * \t\t'),\n * \tcall: defineCall(Fs.abi, {\n * \t\treadFile: async ({ args }) => {\n * \t\t\treturn {\n * \t\t\t\treturnValue: await fs.readFile(...args, 'utf8'),\n * \t\t\t\texecutionGasUsed: 0n,\n * \t\t\t}\n * \t\t},\n * })\n */\nexport abstract class Precompile<\n\tTName extends string,\n\tTHumanReadableAbi extends readonly string[],\n\tTContract extends ReturnType<\n\t\tScript<TName, THumanReadableAbi>['withAddress']\n\t> = ReturnType<Script<TName, THumanReadableAbi>['withAddress']>,\n> {\n\t/**\n\t *\n\t */\n\tpublic abstract readonly contract: TContract\n\tprotected readonly ethjsAddress = () =>\n\t\tAddress.fromString(this.contract.address)\n\tpublic readonly precompile = () => ({\n\t\taddress: this.ethjsAddress(),\n\t\tfunction: (params: { data: Uint8Array; gasLimit: bigint }) => {\n\t\t\treturn this.call({ data: toHex(params.data), gasLimit: params.gasLimit })\n\t\t},\n\t})\n\tpublic abstract readonly call: (context: {\n\t\tdata: Hex\n\t\tgasLimit: bigint\n\t}) => Promise<ExecResult>\n}\n","import { Precompile } from './Precompile.js'\nimport type { Script } from '@tevm/contract'\n\nexport const definePrecompile = <\n\tTName extends string,\n\tTHumanReadableAbi extends readonly string[],\n>({\n\tcontract,\n\tcall,\n}: Pick<\n\tPrecompile<\n\t\tTName,\n\t\tTHumanReadableAbi,\n\t\tReturnType<Script<TName, THumanReadableAbi>['withAddress']>\n\t>,\n\t'contract' | 'call'\n>): Precompile<\n\tTName,\n\tTHumanReadableAbi,\n\tReturnType<Script<TName, THumanReadableAbi>['withAddress']>\n> => {\n\tconst wrappedCall = call\n\tclass PrecompileImplementation extends Precompile<TName, THumanReadableAbi> {\n\t\tcontract = contract\n\t\tcall = wrappedCall\n\t}\n\treturn new PrecompileImplementation()\n}\n","import type { CallResult } from './CallResult.js'\nimport { EVMErrorMessage, EvmError, type ExecResult } from '@ethereumjs/evm'\nimport type {\n\tAbi,\n\tAbiEvent,\n\tAbiParametersToPrimitiveTypes,\n\tExtractAbiFunction,\n\tExtractAbiFunctionNames,\n} from 'abitype'\nimport {\n\tdecodeFunctionData,\n\tencodeAbiParameters,\n\tencodeEventTopics,\n\tencodeFunctionResult,\n\thexToBytes,\n} from 'viem'\n\ntype Handler<\n\tTAbi extends Abi,\n\tTFunctionName extends ExtractAbiFunctionNames<TAbi>,\n> = (params: {\n\tgasLimit: bigint\n\targs: AbiParametersToPrimitiveTypes<\n\t\tExtractAbiFunction<TAbi, TFunctionName>['inputs']\n\t>\n}) => Promise<CallResult<TAbi, TFunctionName>>\n\nexport const defineCall = <TAbi extends Abi>(\n\tabi: TAbi,\n\thandlers: {\n\t\t[TFunctionName in ExtractAbiFunctionNames<TAbi>]: Handler<\n\t\t\tTAbi,\n\t\t\tTFunctionName\n\t\t>\n\t},\n) => {\n\treturn async ({\n\t\tdata,\n\t\tgasLimit,\n\t}: { data: `0x${string}`; gasLimit: bigint }): Promise<ExecResult> => {\n\t\tconst d = decodeFunctionData({\n\t\t\tabi: abi,\n\t\t\tdata: data,\n\t\t})\n\t\tconst handler = handlers[d.functionName]\n\t\ttry {\n\t\t\tconst {\n\t\t\t\treturnValue,\n\t\t\t\texecutionGasUsed,\n\t\t\t\tlogs,\n\t\t\t\terror,\n\t\t\t\tblobGasUsed,\n\t\t\t\tselfdestruct,\n\t\t\t} = await handler({\n\t\t\t\tgasLimit: gasLimit,\n\t\t\t\targs: d.args as any,\n\t\t\t})\n\t\t\treturn {\n\t\t\t\texecutionGasUsed,\n\t\t\t\t...(error ? { exeptionError: error } : {}),\n\t\t\t\t...(selfdestruct ? { selfdestruct } : {}),\n\t\t\t\t...(blobGasUsed ? { blobGasUsed } : {}),\n\t\t\t\t...(logs\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tlogs: logs.map((log) => {\n\t\t\t\t\t\t\t\tconst topics = encodeEventTopics({\n\t\t\t\t\t\t\t\t\tabi,\n\t\t\t\t\t\t\t\t\teventName: log.name,\n\t\t\t\t\t\t\t\t\targs: log.inputs,\n\t\t\t\t\t\t\t\t} as any).map((topics) => hexToBytes(topics))\n\t\t\t\t\t\t\t\tconst eventItem = abi.find(\n\t\t\t\t\t\t\t\t\t(item) => item.type === 'event' && item.name === log.name,\n\t\t\t\t\t\t\t\t) as AbiEvent\n\t\t\t\t\t\t\t\tif (!eventItem)\n\t\t\t\t\t\t\t\t\tthrow new Error(`Event ${log.name} not found in ABI`)\n\t\t\t\t\t\t\t\tconst data = encodeAbiParameters(eventItem.inputs, log.inputs)\n\t\t\t\t\t\t\t\treturn [hexToBytes(log.address), topics, hexToBytes(data)]\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t  }\n\t\t\t\t\t: {}),\n\t\t\t\treturnValue: hexToBytes(\n\t\t\t\t\tencodeFunctionResult({\n\t\t\t\t\t\tabi: abi,\n\t\t\t\t\t\tfunctionName: d.functionName as any,\n\t\t\t\t\t\tresult: returnValue as any,\n\t\t\t\t\t} as any),\n\t\t\t\t),\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn {\n\t\t\t\texecutionGasUsed: BigInt(0),\n\t\t\t\treturnValue: Buffer.alloc(0),\n\t\t\t\texceptionError: {\n\t\t\t\t\t...new EvmError(EVMErrorMessage.REVERT),\n\t\t\t\t\t...{\n\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\ttypeof e === 'string'\n\t\t\t\t\t\t\t\t? e\n\t\t\t\t\t\t\t\t: e instanceof Error\n\t\t\t\t\t\t\t\t? e.message\n\t\t\t\t\t\t\t\t: 'unknown error',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n}\n"]}